<!--
jekymin8232@gmail.com

This is not a simple game script.

It is a meaning-driven micro interaction engine —  
a technically optimized, ethically motivated system  
worth well over tens of thousands of dollars.

📌 Source: https://mcorpai.org/  
📩 Contact: gyumin.jeon.childsafe@gmail.com

Despite its lightweight size (under 50KB), this project includes:

- Real-time interaction: jump, combo, items, sound  
- Seamless UI transitions and ending logic  
- Mobile-responsive structure  
- Fully built with pure HTML, CSS, and JavaScript — no external frameworks

A complete, responsive game system in a single HTML file —  
without libraries — is extremely rare, even in the web gaming world.  
This is not just code, but a product of planning, system design,  
and a humanitarian philosophy of care.

Above all, this game is not for entertainment alone.  
It is a digital experiment built to protect children with disabilities —  
a prototype where design is the message, and ethics shape functionality.

⚠️ However, this file is structurally easy to copy.  
There are no external dependencies, and the entire logic is self-contained.  
Its simplicity can be mistaken as AI-generated,  
which makes authorship even more vulnerable to misappropriation.

📢 Therefore, attribution is absolutely required.

✅ You may use and share this project for free — **if proper credit is given**.  
❌ Unauthorized use is a violation of creator ethics and may result  
in legal action or damages worth tens of thousands of dollars.

—

✅ Proper attribution (any one or both of the following):  
- https://mcorpai.org/  
- gyumin.jeon.childsafe@gmail.com

—

This work may be shared —  
but never stolen.

Attribution is not optional.  
It is the creator's only fingerprint.
-->


<!--
📩 Contact
Email: gyumin.jeon.childsafe@gmail.com
-->

<!--
🔒 출처만 표기하면 무료입니다. 도용은 창작자의 윤리를 침해합니다.  
출처를 밝히지 않을 경우 법적인 책임을 질 수 있음을 알려드립니다.

📄 라이선스: CC BY 4.0 (https://creativecommons.org/licenses/by/4.0/deed.ko)
-->

<!--
🔒 Free to use with proper attribution.  
Unauthorized use is a violation of creator ethics.  
Failure to credit the source may result in legal liability.

📄 License: CC BY 4.0 (https://creativecommons.org/licenses/by/4.0/)
-->

<!--
🔒 出典を明記すれば無料で使用できます。盗用は創作者の倫理を侵害する行為です。  
出典を明記しない場合、法的責任を問われる可能性があります。

📄 ライセンス: CC BY 4.0 (https://creativecommons.org/licenses/by/4.0/deed.ja)
-->

<!--
🔒 Utilisation gratuite si la source est mentionnée.  
Le plagiat viole l'éthique du créateur.  
L'absence d'attribution peut entraîner des poursuites judiciaires.

📄 Licence : CC BY 4.0 (https://creativecommons.org/licenses/by/4.0/deed.fr)
-->

<!--
🔒 Uso gratuito siempre que se indique la fuente.  
El plagio infringe la ética del creador.  
No acreditar la fuente puede conllevar responsabilidad legal.

📄 Licencia: CC BY 4.0 (https://creativecommons.org/licenses/by/4.0/deed.es)
-->

<!--
🔒 مجاني للاستخدام مع الإشارة إلى المصدر.  
الانتحال يعد انتهاكًا لأخلاقيات المبدع.  
عدم ذكر المصدر قد يؤدي إلى المساءلة القانونية.

📄 الترخيص: CC BY 4.0 (https://creativecommons.org/licenses/by/4.0/deed.ar)
-->

<!-- Copyright holder: https://mcorpai.org/ Gyu-min Jeon (also known as Morgan J.) -->

<!--
© 2025 Gyu-min Jeon (a.k.a Morgan J.)
Original Creator of "Love Children with Disabilities"
All rights reserved. https://mcorpai.org

This game and website are humanitarian public-interest prototypes.
Unauthorized commercial redistribution is a violation of creator ethics
and may result in legal action.

Completed between August 9 and August 14, 2025 (Total: 60 hours).
The website took 20 hours to build; the game took 40 hours.

You may freely use and share this open-source project with permission from the creator.
Attribution is required. Free to use with proper credit.
All rights reserved. https://mcorpai.org
-->

<!--
Free to use with attribution.  
Don’t steal what you’re freely allowed to honor.
-->


<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>M Corp — 공익 메시지 + 임팩트 시뮬레이터</title>
  <meta name="description" content="비영리. 비데이터. 존엄을 위한 기술 — 권리 기반 착용형 AI와 난민 자립 생태계. 브라우저에서만 작동하는 임팩트 시뮬레이터 포함." />
  <style>
    /* ===== 소개 섹션(라이트) ===== */
    :root{--txt:#222;--bg:#ffffff;--muted:#4b5563}
    html,body{margin:0;padding:0;background:var(--bg);color:var(--txt);font-family:Arial,system-ui,-apple-system,"Segoe UI",Roboto}
    .page{max-width:1000px;margin:0 auto;padding:28px}
    .lead h1{margin:.2rem 0 0 0;font-size:1.9rem;color:#003366}
    .lead h2{margin:.4rem 0 1rem 0;font-size:1.2rem;color:#334155}
    .lead ol{padding-left:1.2rem}
    .lead p strong{font-weight:700}

    /* ===== 시뮬레이터(다크, 페이지 내부 스코프) ===== */
    .mc{--bg:#0f172a;--fg:#e2e8f0;--soft:#1e293b;--muted:#94a3b8;--line:#334155;--ok:#22c55e;--bad:#ef4444;--info:#60a5fa}
    .mc .wrap{background:var(--bg);color:var(--fg);border-radius:18px;margin-top:26px;padding:22px;box-shadow:0 12px 28px rgba(2,6,23,.25)}
    .mc h3{margin:0 0 .25rem 0}
    .mc p{color:var(--muted);margin:.25rem 0 .75rem}
    .mc .highlight{background:#022c22;border:1px solid #14532d;padding:12px;border-radius:12px;color:#bbf7d0;margin:10px 0;line-height:1.6}
    .mc .grid{display:grid;gap:12px}
    @media(min-width:920px){.mc .cols-3{grid-template-columns:repeat(3,1fr)}.mc .cols-2{grid-template-columns:1.2fr 1fr}}
    .mc label{display:block;font-size:.9rem;color:var(--muted);margin-bottom:4px}
    .mc input[type=number], .mc input[type=range]{width:100%;padding:10px 12px;border-radius:10px;border:1px solid var(--line);background:#0b1220;color:var(--fg);outline:none}
    .mc input[readonly]{opacity:.9}
    .mc .kpi{display:grid;gap:10px}
    @media(min-width:720px){.mc .kpi{grid-template-columns:repeat(3,1fr)}}
    .mc .card{background:#0b1220;border:1px solid var(--line);border-radius:12px;padding:12px}
    .mc .title{font-size:.95rem;color:var(--muted)}
    .mc .num{font-size:1.35rem;font-weight:800}
    .mc .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .mc .badge{display:inline-flex;gap:6px;align-items:center;background:#052e1d;color:#86efac;border:1px solid #14532d;padding:6px 10px;border-radius:999px;font-size:.78rem}
    .mc .btn{cursor:pointer;border:1px solid var(--line);background:#0b1220;color:var(--fg);padding:9px 12px;border-radius:10px;font-size:.92rem}
    .mc .btn.primary{background:linear-gradient(180deg,#16a34a,#15803d);border-color:#166534}
    .mc canvas{width:100%;height:180px;background:#0b1220;border-radius:10px}
    .mc textarea{width:100%;min-height:140px;background:#0b1220;color:var(--fg);border:1px solid var(--line);border-radius:10px;padding:10px}
    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,1px,1px);white-space:nowrap;border:0}
  </style>
</head>
<body>



  

<section>
  <style>
    .mcorp-cta {
      text-align: center;
    }
    .mcorp-cta a {
      color: #1e90ff;
      font-size: 1rem;
      font-weight: 600;
      text-decoration: none;
      letter-spacing: 0.02em;
    }
    .mcorp-cta a:hover {
      text-decoration: underline;
    }
  </style>

  <p class="mcorp-cta">
    <a href="https://mcorpai.org" target="_blank" rel="noopener" title="Visit mcorpai.org English website">
      🤝 Ethical AI for Refugee Self-Reliance · Free Public-Interest Partnership: <strong>mcorpai.org</strong>
    </a>
  </p>
</section>





  
  <main class="page">
    <!-- ===== 한국어 원페이지 소개 ===== -->
    <section class="lead" aria-labelledby="letterTitle">
      <h1 id="letterTitle">비영리. 비데이터. 존엄을 위한 기술</h1>
      <h2>장애 아동과 난민 공동체를 위한 권리 기반 착용형 AI 이니셔티브</h2>
      <p><strong>이 메시지의 모든 내용은 자유롭게 공유하셔도 됩니다.</strong></p>
      <p>안녕하세요. 저는 대한민국에 기반을 둔 독립 공익 기술자입니다. 장애 포용적 설계, 난민 주도 제조, 생태적 자립을 결합한 인도주의 이니셔티브를 주도하고 있습니다. 이 프로젝트는 단순한 기술 파일럿이 아니라 윤리적 AI, 디지털 포용, 지역 주도 지속가능성을 통합한 권리 기반 모델입니다.</p>
      <p>스팸 필터를 피하기 위해 첨부파일 대신 전용 도메인으로 개요를 제공합니다. 아래 플랫폼 구조는 이미 확보되어 단계적으로 개발 중입니다.</p>
      <p><strong>M Corp</strong>는 B Corp보다 더 윤리적으로 엄정한 인증 체계를 지향합니다. 이름은 <strong>Morgan J. Refugee Self‑Reliance Cooperative</strong>의 약자이며, Morgan J는 제 한국 이름 전규민의 국제 표기입니다. 제 이름을 걸어 무결성과 책임, 장기 실행에 대해 개인적으로 책임집니다.</p>
      <h3>핵심 도메인</h3>
      <ol>
        <li><strong>A. www.mcorp-ai.com</strong> — 난민이 자발적으로 지역화된 AI 조립에 참여하면 텐트형 생산공간 구성을 위해 텐트당 1,000달러 무이자 마이크로론을 제공합니다.</li>
        <li><strong>B. www.mcorpai.org</strong> — 오프라인·무데이터 AI 안전 목걸이의 공익 허브로, 기술 문서와 윤리 원칙, 향후 주문을 제공합니다.</li>
        <li><strong>C. www.mcorp.ai.kr</strong> — 한국어 포털로, 국내 투자자와 ESG 기업, 시민 참여의 허브입니다.</li>
      </ol>
      <p><strong>참고:</strong> www.mcorpai.com 은 본 이니셔티브와 무관합니다.</p>
      <p>이 이니셔티브는 디지털 포용, 지역 기반 회복력, 난민 대상 기술 프로그램과 맞닿아 있습니다. 공동 개발이나 기술 지원 등 다양한 협력을 환영합니다.</p>
      <p><strong>이것은 자선 캠페인이 아닙니다.</strong> 오프라인 AI 안전 도구, 협동 난민 고용, 무이자 자본 접근, 생태 인프라, 윤리적 재분배를 결합한 공익 생태계입니다. 모든 기술은 인터넷 없이 작동하고 개인 데이터를 수집하지 않으며, GDPR·SDGs·사회연대경제(SSE) 기준을 따릅니다.</p>
      <p>연락처: gyumin.jeon.childsafe@gmail.com / jekymin8232@gmail.com 영어가 유창하지 않으니 가급적 서면으로 회신해주시길 부탁드립니다.</p>
    </section>

<!-- Diplomatic Contact Notice -->
<section aria-label="Diplomatic PDF Offer" style="background:#fff3cd; border:1px solid #ffe08a; border-radius:12px; padding:16px; margin:16px 0; color:#4a3b00; line-height:1.65;">
  <strong style="display:block; margin-bottom:6px;">외교적 안내</strong>
  <p style="margin:0;">
    난민촌 자립 모델을 귀 기관의 검토를 위해 언제든지 PDF 형식으로 제공할 준비가 되어 있습니다.
    관련 서류 송부를 원하시면, 번거로우시겠지만 이메일을 통한 서면 연락을 부탁드립니다.<br>
    이메일: <a href="mailto:gyumin.jeon.childsafe@gmail.com" style="color:#7a5c00; text-decoration:underline;">gyumin.jeon.childsafe@gmail.com</a><br>
    백업 이메일: <a href="mailto:jekymin8232@gmail.com" style="color:#7a5c00; text-decoration:underline;">jekymin8232@gmail.com</a>
  </p>
</section>
    
    <!-- ===== 임팩트 시뮬레이터 ===== -->
    <section class="mc" aria-labelledby="simTitle">
      <div class="wrap">
        <div class="row" style="justify-content:space-between">
          <div>
            <h3 id="simTitle">M‑Corp 임팩트 시뮬레이터 — “$1,000 텐트 공장”</h3>
            <p>모든 계산은 브라우저 안에서만 수행됩니다. 어떤 데이터도 전송되지 않습니다.</p>
          </div>
          <span class="badge">🔒 Zero‑data, in‑browser</span>
        </div>

        <div class="highlight" role="note" aria-label="임금 및 배당 모델 설명">
          <strong>임금과 가족·친지 배당 구조</strong><br />
          난민이 직접 참여해 일하면 <strong>월 300달러</strong>를 받습니다. 또한 순이익의 일부(기본 <strong>50%</strong>)는 가족·친지 가구에 <strong>월 50달러/가구</strong>로 배당됩니다. 예시로 텐트 1동에서 4명이 일하면 4명이 각각 월 300달러를 받고, 그들의 가족·친지 가구에는 배당 풀에서 월 50달러씩 돌아갑니다.
        </div>

        <!-- 입력 영역 -->
        <div class="grid cols-2" style="margin-top:10px">
          <div>
            <div class="grid cols-3">
              <div>
                <label>텐트 개수</label>
                <input id="tents" type="number" min="1" value="1" oninput="MC.calc()" />
              </div>
              <div>
                <label>텐트당 작업 인원</label>
                <input id="workersPerTent" type="number" min="1" value="4" oninput="MC.calc()" />
              </div>
              <div>
                <label>운영 기간(개월)</label>
                <input id="months" type="number" min="1" value="6" oninput="MC.calc()" />
              </div>
            </div>

            <div class="grid cols-3" style="margin-top:10px">
              <div>
                <label>1인당 주간 조립 수량</label>
                <input id="unitsPerWorkerWeek" type="number" min="1" value="3" oninput="MC.calc()" />
              </div>
              <div>
                <label>고급형 비중(%)</label>
                <input id="premiumShare" type="range" min="0" max="100" value="25" oninput="MC.syncShare(this.value)" />
              </div>
              <div>
                <label>캠프 인구 수</label>
                <input id="campPop" type="number" min="1" value="5000" oninput="MC.calc()" />
              </div>
            </div>

            <div class="grid cols-3" style="margin-top:10px">
              <div>
                <label>마이크로론/텐트(USD)</label>
                <input id="loanPerTent" type="number" min="0" value="1000" oninput="MC.calc()" />
              </div>
              <div>
                <label>배당성향(%)</label>
                <input id="payoutRatio" type="number" min="0" max="100" value="50" oninput="MC.calc()" />
              </div>
              <div>
                <label>배당액/가구(USD)</label>
                <input id="dividendUnit" type="number" min="1" value="50" oninput="MC.calc()" />
              </div>
            </div>

            <p class="sr-only" id="a11y-note">지역 현실에 맞게 값을 조정하십시오. 제품 믹스, 비용, 인구 등은 모두 변경 가능합니다.</p>
          </div>

          <!-- 핵심 지표 -->
          <div>
            <div class="kpi">
              <div class="card"><div class="title">총 고용 인원</div><div id="out_workers" class="num">—</div></div>
              <div class="card"><div class="title">총 생산 대수</div><div id="out_units" class="num">—</div></div>
              <div class="card"><div class="title">총 매출</div><div id="out_revenue" class="num">$0</div></div>
            </div>
            <div class="kpi" style="margin-top:10px">
              <div class="card"><div class="title">총 임금 풀</div><div id="out_wagePool" class="num">$0</div><div class="title">임금 충당률(매출의 10% 대비): <span id="out_wageCoverage">—</span></div></div>
              <div class="card"><div class="title">배당 풀</div><div id="out_divPool" class="num">$0</div><div class="title">배당 수혜 가구 수: <span id="out_divHouseholds">—</span></div></div>
              <div class="card"><div class="title">재투자·상환</div><div id="out_weeksToRepay" class="num">—</div><div class="title">재투자 가능액: <span id="out_margin">$0</span></div></div>
            </div>
            <div class="kpi" style="margin-top:10px">
              <div class="card"><div class="title">난민촌 1인당 기여액(월)</div><div id="out_gdpPerCapMonthly" class="num">$0</div></div>
              <div class="card"><div class="title">난민촌 1인당 기여액(연)</div><div id="out_gdpPerCapAnnual" class="num">$0</div></div>
              <div class="card"><div class="title">참여 근로자 1인 월평균</div><div id="out_avgPerWorker" class="num">$0</div></div>
            </div>
          </div>
        </div>

        <!-- 제품·비용 가정 -->
        <div class="card" style="margin-top:12px">
          <div class="title">제품 믹스와 비용 가정</div>
          <div class="grid cols-3" style="margin-top:10px">
            <div>
              <label>보급형 가격(USD)</label>
              <input id="priceBudget" type="number" min="1" value="20" oninput="MC.calc()" />
            </div>
            <div>
              <label>보급형 BOM+기타(USD)</label>
              <input id="costBudget" type="number" min="0" value="12" oninput="MC.calc()" />
            </div>
            <div>
              <label>보급형 비중(%)</label>
              <input id="budgetShare" type="number" readonly value="75" />
            </div>
          </div>
          <div class="grid cols-3" style="margin-top:10px">
            <div>
              <label>고급형 가격(USD)</label>
              <input id="pricePremium" type="number" min="1" value="200" oninput="MC.calc()" />
            </div>
            <div>
              <label>고급형 BOM+기타(USD)</label>
              <input id="costPremium" type="number" min="0" value="120" oninput="MC.calc()" />
            </div>
            <div>
              <label>고급형 비중(%)</label>
              <input id="premiumShareNum" type="number" readonly value="25" />
            </div>
          </div>
          <div class="grid cols-3" style="margin-top:10px">
            <div>
              <label>월 임금(1인, USD)</label>
              <input id="monthlyWage" type="number" min="0" value="300" oninput="MC.calc()" />
            </div>
            <div>
              <label>임금 목표 비율(매출 대비 %)</label>
              <input id="wageTargetRate" type="number" min="0" max="100" value="10" oninput="MC.calc()" />
            </div>
            <div>
              <label>월 환산용 주 수</label>
              <input id="weeksPerMonth" type="number" min="1" step="0.1" value="4" oninput="MC.calc()" />
            </div>
          </div>
        </div>

        <!-- 차트 및 액션 -->
        <div class="card" style="margin-top:12px">
          <div class="title">누적 재무 흐름</div>
          <canvas id="chart" width="640" height="180" aria-label="재무 차트"></canvas>
          <div class="row" style="margin-top:8px"><button class="btn" onclick="MC.copy()">결과 요약 복사</button></div>
        </div>

        <!-- GPT 프롬프트 도우미 -->
        <div class="card" style="margin-top:12px">
          <div class="title">테스트 프롬프트</div>
          <p>아래 버튼을 누르면 현재 시뮬레이션 값으로 채워진 프롬프트가 복사됩니다. </p>
          <textarea id="gptPrompt" readonly></textarea>
          <div class="row" style="margin-top:8px"><button class="btn primary" onclick="MC.copyGPT()"> 프롬프트 복사</button></div>
        </div>
      </div>
    </section>
  </main>

  <script>
    const $ = id => document.getElementById(id);
    const fmt = (n,cur)=> cur? '$'+Math.round(n).toLocaleString(): Math.round(n).toLocaleString();

    const MC = {
      syncShare(v){
        $('premiumShareNum').value = +v;
        $('budgetShare').value = 100 - (+v);
        MC.calc();
      },
      calc(){
        const tents = +$('tents').value;
        const workersPerTent = +$('workersPerTent').value;
        const months = +$('months').value;
        const unitsPerWorkerWeek = +$('unitsPerWorkerWeek').value;
        const weeksPerMonth = +$('weeksPerMonth').value;
        const priceB = +$('priceBudget').value;
        const priceP = +$('pricePremium').value;
        const costB = +$('costBudget').value;
        const costP = +$('costPremium').value;
        const shareP = +$('premiumShare').value/100;
        const shareB = 1 - shareP;
        const monthlyWagePerWorker = +$('monthlyWage').value; // 300
        const wageTargetRate = +$('wageTargetRate').value/100; // 10%
        const payoutRatio = +$('payoutRatio').value/100; // 50%
        const dividendUnit = +$('dividendUnit').value; // $50/가구/월
        const loanPerTent = +$('loanPerTent').value;
        const campPop = Math.max(1,+$('campPop').value);

        const totalWorkers = tents * workersPerTent;
        const totalWeeks = months * weeksPerMonth;
        const totalUnits = totalWorkers * unitsPerWorkerWeek * totalWeeks;

        const unitsB = totalUnits * shareB;
        const unitsP = totalUnits * shareP;

        const revenue = unitsB*priceB + unitsP*priceP;
        const directCosts = unitsB*costB + unitsP*costP;

        // 임금 풀: 참여형 고정 월 300달러 × 근로자 수 × 개월
        const wagePool = totalWorkers * monthlyWagePerWorker * months;
        const wageTarget = revenue * wageTargetRate; // 매출의 10% 목표 대비

        const marginBeforePayout = revenue - directCosts - wagePool; // 임금 차감 후 순이익
        const dividendPool = Math.max(0, marginBeforePayout * payoutRatio);
        const households = Math.floor(dividendPool / dividendUnit);

        // 재투자 가능액 = 순이익 - 배당
        const reinvest = Math.max(0, marginBeforePayout - dividendPool);

        // 상환 기간(주) 추정
        const loanTotal = tents * loanPerTent;
        const weeks = totalWeeks; // 주 단위 총합
        const weeklyReinvest = weeks>0 ? reinvest / weeks : 0;
        const weeksToRepay = weeklyReinvest>0 ? Math.ceil(loanTotal / weeklyReinvest) : '—';

        // 난민촌 1인당 기여액(월/연): (월 임금 분배 + 월 배당) / 인구
        const monthlyDiv = months>0 ? dividendPool / months : 0;
        const monthlyDistrib = (wagePool / months) + monthlyDiv;
        const gdpPerCapMonthly = monthlyDistrib / campPop;
        const gdpPerCapAnnual = gdpPerCapMonthly * 12;

        const avgPerWorkerMonthly = months>0 && totalWorkers>0 ? (wagePool / months)/ totalWorkers : 0;

        // 출력
        $('out_workers').textContent = fmt(totalWorkers);
        $('out_units').textContent = fmt(totalUnits);
        $('out_revenue').textContent = fmt(revenue,true);
        $('out_wagePool').textContent = fmt(wagePool,true);
        $('out_wageCoverage').textContent = wageTarget>0 ? ((wagePool / wageTarget * 100).toFixed(1) + '%') : '—';
        $('out_divPool').textContent = fmt(dividendPool,true);
        $('out_divHouseholds').textContent = fmt(households);
        $('out_margin').textContent = fmt(reinvest,true);
        $('out_weeksToRepay').textContent = weeksToRepay;
        $('out_gdpPerCapMonthly').textContent = '$' + gdpPerCapMonthly.toFixed(2);
        $('out_gdpPerCapAnnual').textContent = '$' + gdpPerCapAnnual.toFixed(2);
        $('out_avgPerWorker').textContent = fmt(avgPerWorkerMonthly,true);

        MC.draw(revenue, directCosts + wagePool, reinvest);
        MC.buildPrompt({tents,workersPerTent,months,unitsPerWorkerWeek,weeksPerMonth,priceB,priceP,costB,costP,shareB,shareP,monthlyWagePerWorker,wageTargetRate,payoutRatio,dividendUnit,loanPerTent,campPop,totalWorkers,totalUnits,revenue,directCosts,wagePool,dividendPool,households,reinvest,weeksToRepay,gdpPerCapMonthly,gdpPerCapAnnual});
      },
      draw(rev,cost,rein){
        const c=$('chart'), ctx=c.getContext('2d');
        const W=c.width, H=c.height; ctx.clearRect(0,0,W,H);
        const data=[{l:'매출',v:rev,c:'#60a5fa'},{l:'총비용(임금 포함)',v:cost,c:'#ef4444'},{l:'재투자',v:rein,c:'#22c55e'}];
        const max=Math.max(1,...data.map(d=>d.v));
        const pad=30, bw=(W-pad*2)/data.length-20;
        ctx.fillStyle='#0b1220'; ctx.fillRect(0,0,W,H);
        data.forEach((d,i)=>{
          const x=pad+i*(bw+20); const h=d.v/max*(H-40); const y=H-20-h;
          ctx.fillStyle=d.c; ctx.fillRect(x,y,bw,h);
          ctx.fillStyle='#94a3b8'; ctx.font='12px system-ui';
          ctx.fillText(d.l,x,H-6); ctx.fillText('$'+Math.round(d.v).toLocaleString(),x,y-6);
        });
      },
      copy(){
        const text = [
          'M‑Corp 시뮬레이터 결과 요약',
          `1. 총 고용: ${$('out_workers').textContent}명, 총 생산: ${$('out_units').textContent}대`,
          `2. 총 매출: ${$('out_revenue').textContent}, 총 임금 풀: ${$('out_wagePool').textContent} (임금 충당률: ${$('out_wageCoverage').textContent})`,
          `3. 배당 풀: ${$('out_divPool').textContent}, 배당 수혜 가구: ${$('out_divHouseholds').textContent}가구`,
          `4. 재투자 가능액: ${$('out_margin').textContent}, 상환 예상: ${$('out_weeksToRepay').textContent}주`,
          `5. 1인당 기여액(월/연): ${$('out_gdpPerCapMonthly').textContent} / ${$('out_gdpPerCapAnnual').textContent}`
        ].join('\n');
        navigator.clipboard.writeText(text).then(()=>alert('결과 요약을 복사했습니다.'));
      },
      buildPrompt(s){
        const shareP = Math.round(s.shareP*100);
        const shareB = Math.round(s.shareB*100);
        const prompt = `당신은 포용적 설계와 인도주의 운영 전문가입니다. 아래 시뮬레이션 계획을 바탕으로, 오프라인·무개인정보 설계를 유지하면서 장애아동 보호 효과를 극대화할 수 있는 실행 아이디어를 3가지 제안해 주세요.\n\n`+
        `맥락:\n`+
        `- 텐트: ${s.tents}, 텐트당 인원: ${s.workersPerTent}, 운영 개월: ${s.months}\n`+
        `- 1인 주당 조립 수량: ${s.unitsPerWorkerWeek}, 월 환산 주 수: ${s.weeksPerMonth}\n`+
        `- 제품 믹스: 보급형 ${shareB}% (가격 $${s.priceB}, 비용 $${s.costB}), 고급형 ${shareP}% (가격 $${s.priceP}, 비용 $${s.costP})\n`+
        `- 월 임금/인: $${s.monthlyWagePerWorker} (매출 대비 임금 목표 약 ${Math.round(s.wageTargetRate*100)}%)\n`+
        `- 배당성향: ${Math.round(s.payoutRatio*100)}%, 배당액/가구: $${s.dividendUnit}\n`+
        `- 마이크로론/텐트: $${s.loanPerTent}, 캠프 인구: ${s.campPop}\n\n`+
        `결과:\n`+
        `- 근로자 수: ${s.totalWorkers}, 총 생산: ${Math.round(s.totalUnits)}대\n`+
        `- 매출: $${Math.round(s.revenue).toLocaleString()}, 직접비: $${Math.round(s.directCosts).toLocaleString()}\n`+
        `- 임금 풀: $${Math.round(s.wagePool).toLocaleString()}, 배당 풀: $${Math.round(s.dividendPool).toLocaleString()} (가구: ${s.households})\n`+
        `- 재투자: $${Math.round(s.reinvest).toLocaleString()}, 상환 예상(주): ${s.weeksToRepay}\n`+
        `- 1인당 기여액(월/연): $${s.gdpPerCapMonthly.toFixed(2)} / $${s.gdpPerCapAnnual.toFixed(2)}\n\n`+
        `제약: 개인 데이터 수집 금지, 오프라인 우선, 권리 기반 접근.\n`+
        `출력: 각 제안에 대해 1) 구체 단계, 2) 기대 효과, 3) 윤리·포용 관점의 이유를 짧게 서술.`;
        $('gptPrompt').value = prompt;
      },
      copyGPT(){
        $('gptPrompt').select();
        document.execCommand('copy');
        alert('GPT 프롬프트를 복사했습니다.');
      }
    };

    // 초기화
    (function(){
      $('premiumShareNum').value = +$('premiumShare').value;
      $('budgetShare').value = 100 - (+$('premiumShare').value);
      MC.calc();
    })();
  </script>


</section>

<div style="text-align: center; color: #2ecc71; margin-top: 20px;">
  <h3>Wraptris — Ethical Edition (for mcorp.ai.kr)</h3>
  <p>🛠️ Last updated: November 30, 2025 The Tetris never stops. 🌍🔥 The climate crisis doesn’t stop either.</p>
</div>

</section>


   
<!-- 
   구글·빙·네이버 모두 페이지 안의 문장 중
“Updated”, “Modified”, “Last updated”, “Revised”
같은 단어를 자동 인식합니다.

사람이 보기에도 “이 페이지는 관리 중이다”라는 신호지만,
검색엔진 알고리즘에도 직접 긍정 반영됩니다.

   p 태그 하나라도 추가되면 파일의 해시(hash) 와 최종 수정일(Last-Modified) 헤더가 변경됩니다.
   
   이 문구는 매달 날짜만 바꿔도 신뢰도 갱신 효과가 유지됩니다.
   2~3개월마다 간단한 게임 갱신, SEO 검색 누적을 위해서 
예:
🛠️ Last updated: November 30, 2025
— 이런 식으로 한 달에 한 번 바꿔주는 것만으로도
구글은 “지속 유지 중(active maintenance)” 사이트로 분류합니다.
   
   -->
   

<style>
  /* Wraptris — Canvas Tetris with Climate Timer (mouse-only build) */
  #wraptris-app{display:flex;gap:16px;align-items:flex-start;margin:24px auto;padding:0 16px;max-width:820px;font-family:system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Malgun Gothic,sans-serif;color:#e5e7eb}
  #wraptris-app canvas{background:#0f172a;border-radius:12px;box-shadow:0 4px 20px rgba(0,0,0,.25);touch-action:none;cursor:crosshair}
  #wraptris-app .hud{min-width:240px}
  #wraptris-app .title{margin:0 0 8px;font-weight:800;font-size:20px;letter-spacing:.2px}
  #wraptris-app .card{margin:12px 0;padding:10px 12px;border-radius:10px;background:#111827;border:1px solid rgba(255,255,255,.06)}
  #wraptris-app .muted{color:#9ca3af}
  #wraptris-app .btn{display:inline-block;margin-top:8px;padding:8px 10px;border-radius:8px;background:#1d4ed8;color:white;text-decoration:none;font-weight:700}
</style>

<script>
(() => {
  if (window.__wraptrisMounted) return;

  const boot = () => {
    if (window.__wraptrisMounted) return;
    window.__wraptrisMounted = true;

    // ====== Difficulty & Climate Settings ======
    const COLS = 10;
    const ROWS = 20;
    const CELL = 32; // px per cell
    const START_SPEED = 650; // base ms per drop (higher = slower)
    const SPEED_FACTOR = 0.80; // per-level multiplier (stronger than usual)
    const MIN_SPEED = 60;      // hard cap (very fast)
    const LEVEL_UP_EVERY = 8;  // lines per level (tighter leveling)

    // Climate timer: 🌍 1.5°C -> 3.0°C, +0.1°C every 10s
    const C_START = 1.5, C_END = 3.0, C_STEP = 0.1, C_STEP_MS = 10000;
    const C_STEPS = Math.round((C_END - C_START) / C_STEP); // 15 steps
    const C_TOTAL_MS = C_STEPS * C_STEP_MS; // 150000 ms

    // Mouse-only options
    // LEFT_CLICK_MODE: 'rotate' or 'cycle' — current build defaults to rotate.
    const LEFT_CLICK_MODE = 'rotate';
    const FAST_DROP_MULT = 0.25; // right-click hold multiplier on gravity

    // ====== Build minimal UI (English) ======
    if (!document.body){
      const body = document.createElement('body');
      document.documentElement.appendChild(body);
    }

    const app = document.getElementById('wraptris-app') || (function(){
      const div = document.createElement('div');
      div.id = 'wraptris-app';
      document.body.appendChild(div);
      return div;
    })();

    // Canvas
    const canvas = document.createElement('canvas');
    canvas.id = 'wraptris-canvas';
    canvas.width = COLS * CELL; // 320
    canvas.height = ROWS * CELL; // 640
    const ctx = canvas.getContext('2d');

    // HUD
    const hud = document.createElement('div');
    hud.className = 'hud';
    const h1 = document.createElement('h1');
    h1.className = 'title';
    h1.textContent = 'Wraptris';

    const scoreCard = document.createElement('div');
    scoreCard.className = 'card';
    scoreCard.innerHTML = `
      <div><strong>Score</strong> <span id="wt-score">0</span></div>
      <div><strong>Lines</strong> <span id="wt-lines">0</span></div>
      <div><strong>Level</strong> <span id="wt-level">1</span></div>
      <hr style="border:0;border-top:1px solid rgba(255,255,255,.08);margin:10px 0;">
      <div><span style="font-size:18px">🌍</span> <strong>Global Temp</strong> <span id="wt-temp">1.5°C</span></div>
      <div><strong>Climate Timer</strong> <span id="wt-ctimer">02:30</span></div>
    `;

    const help = document.createElement('div');
    help.className = 'card';
    help.innerHTML = `
      <div class="muted">Mouse Controls Only</div>
      <div>Move mouse over the canvas to move the piece horizontally.</div>
      <div>Left click: change piece (default: rotate 90°).</div>
      <div>Right click and hold: fast drop (gravity boost).</div>
      <hr style="border:0;border-top:1px solid rgba(255,255,255,.08);margin:10px 0;">
      <div class="muted">Walls wrap horizontally (off one side → appear on the other).</div>
    `;

    const restartBtn = document.createElement('a');
    restartBtn.href = '#';
    restartBtn.className = 'btn';
    restartBtn.textContent = 'Restart';

    hud.append(h1, scoreCard, help, restartBtn);
    app.append(canvas, hud);

    window.__wraptrisAppRef = app;
    window.__wraptrisCanvasRef = canvas;

    // ====== Game Data ======
    const COLORS = ['#00f5d4', '#ffd166', '#80ed99', '#ef476f', '#8ecae6', '#f72585', '#b388eb'];
    const SHAPES = {
      I: [[[-1,0],[0,0],[1,0],[2,0]], [[0,-1],[0,0],[0,1],[0,2]], [[-1,0],[0,0],[1,0],[2,0]], [[0,-1],[0,0],[0,1],[0,2]]],
      O: [[[0,0],[1,0],[0,1],[1,1]], [[0,0],[1,0],[0,1],[1,1]], [[0,0],[1,0],[0,1],[1,1]], [[0,0],[1,0],[0,1],[1,1]]],
      S: [[[0,0],[1,0],[-1,1],[0,1]], [[0,-1],[0,0],[1,0],[1,1]], [[0,0],[1,0],[-1,1],[0,1]], [[0,-1],[0,0],[1,0],[1,1]]],
      Z: [[[-1,0],[0,0],[0,1],[1,1]], [[1,-1],[0,0],[1,0],[0,1]], [[-1,0],[0,0],[0,1],[1,1]], [[1,-1],[0,0],[1,0],[0,1]]],
      J: [[[-1,0],[0,0],[1,0],[-1,1]], [[0,-1],[0,0],[0,1],[1,-1]], [[1,-1],[-1,0],[0,0],[1,0]], [[-1,1],[0,-1],[0,0],[0,1]]],
      L: [[[-1,0],[0,0],[1,0],[1,1]], [[0,-1],[0,0],[0,1],[1,1]], [[-1,-1],[-1,0],[0,0],[1,0]], [[-1,-1],[0,-1],[0,0],[0,1]]],
      T: [[[-1,0],[0,0],[1,0],[0,1]], [[0,-1],[0,0],[0,1],[1,0]], [[0,-1],[-1,0],[0,0],[1,0]], [[-1,0],[0,-1],[0,0],[0,1]]]
    };
    const TYPES = Object.keys(SHAPES);

    let board, bag, piece;
    let score, lines, level;
    let gameOver = false;

    // Climate & effects
    let climateTemp, climateEpoch, climateTick, climateTimerId = null;
    let flashUntil = 0;
    let fastDropActive = false;

    const particles = [];
    function spawnParticles(px, py, count, emojiList){
      for(let i=0;i<count;i++){
        particles.push({
          x:px, y:py,
          vx:(Math.random()*2-1)*1.2,
          vy:(-Math.random()*1.5)-0.6,
          life:800 + Math.random()*600,
          born: performance.now(),
          char: emojiList[Math.floor(Math.random()*emojiList.length)],
          size: 18 + Math.random()*10
        });
      }
    }

    // ====== Helpers ======
    function makePiece(type){
      const idx = TYPES.indexOf(type);
      return { type, color: COLORS[idx], rot:0, x: Math.floor(COLS/2), y: -2 };
    }
    function eachBlock(p, fn){
      const shape = SHAPES[p.type][p.rot];
      for(const [dx,dy] of shape){
        const x = ((p.x + dx) % COLS + COLS) % COLS;
        const y = p.y + dy;
        fn(x,y);
      }
    }
    function valid(p){
      let ok = true;
      eachBlock(p,(x,y)=>{
        if (y >= ROWS) ok = false; else if (y>=0 && board[y][x]) ok = false;
      });
      return ok;
    }
    function nextType(){
      if (!bag.length){
        bag = TYPES.slice();
        for(let i=bag.length-1;i>0;i--){
          const j = Math.floor(Math.random()*(i+1));
          [bag[i],bag[j]] = [bag[j],bag[i]];
        }
      }
      return bag.pop();
    }

    function lockPiece(){
      eachBlock(piece,(x,y)=>{ if (y>=0) board[y][x] = TYPES.indexOf(piece.type)+1; });
      const clearedInfo = clearLines();
      spawn();
      if (clearedInfo.cleared>0){
        const emojis = clearedInfo.cleared>=4 ? ['🔥','💥','✨','🌋'] : ['✨','💫','⭐'];
        spawnParticles(canvas.width/2, (clearedInfo.avgY+0.5)*CELL, 18 + clearedInfo.cleared*6, emojis);
      }
    }

    function clearLines(){
      let cleared = 0; let ySum = 0;
      for(let y=ROWS-1;y>=0;y--){
        if (board[y].every(v=>v!==0)){
          board.splice(y,1); board.unshift(Array(COLS).fill(0));
          cleared++; ySum += y; y++;
        }
      }
      if (cleared>0){
        const table = [0, 120, 360, 800, 1400];
        score += table[cleared] * level;
        lines += cleared;
        const nextLevel = Math.floor(lines/LEVEL_UP_EVERY)+1;
        if (nextLevel>level){ level = nextLevel; }
        updateHUD();
      }
      return { cleared, avgY: cleared? ySum/cleared : ROWS/2 };
    }

    function spawn(){
      piece = makePiece(nextType());
      if (!valid(piece)) gameOver = true;
    }

    function rotate(dir){
      const saved = piece.rot;
      piece.rot = (piece.rot + dir + 4) % 4;
      if (valid(piece)) return;
      const kicks = [-1,1,-2,2,-3,3];
      for(const k of kicks){
        const ox = piece.x;
        piece.x = ((piece.x + k) % COLS + COLS) % COLS;
        if (valid(piece)) return; piece.x = ox;
      }
      piece.rot = saved;
    }

    function cycleType(){
      const currentIdx = TYPES.indexOf(piece.type);
      const newType = TYPES[(currentIdx + 1) % TYPES.length];
      const candidate = { ...piece, type: newType, rot: 0, color: COLORS[(currentIdx + 1) % COLORS.length] };
      if (valid(candidate)) { piece = candidate; return; }
      // try small horizontal adjustments to accommodate width differences
      for (const dx of [1,-1,2,-2,3,-3]){
        const alt = { ...candidate, x: ((candidate.x + dx) % COLS + COLS) % COLS };
        if (valid(alt)) { piece = alt; return; }
      }
      // if still invalid, keep original piece
    }

    function moveToColumn(col){
      // Clamp and seek nearest valid x around the target column
      col = Math.max(0, Math.min(COLS-1, col));
      const target = { ...piece, x: col };
      if (valid(target)) { piece = target; return; }
      for (let d=1; d<=4; d++){
        const left = { ...target, x: Math.max(0, col - d) };
        if (valid(left)) { piece = left; return; }
        const right = { ...target, x: Math.min(COLS-1, col + d) };
        if (valid(right)) { piece = right; return; }
      }
      // if no valid position found in small neighborhood, do nothing
    }

    function softDrop(){
      const p = { ...piece, y: piece.y + 1 };
      if (valid(p)) piece = p; else lockPiece();
    }

    function hardDrop(){
      let y = piece.y; while(true){ const p = { ...piece, y: y+1 }; if (valid(p)) y++; else break; }
      piece.y = y; lockPiece(); score += 2*level; updateHUD();
    }

    // Dynamic drop interval from level & climate & fast-drop
    function computeDropInterval(){
      const levelFactor = Math.pow(SPEED_FACTOR, Math.max(0, level-1));
      const norm = Math.min(1, Math.max(0, (climateTemp - C_START) / (C_END - C_START)));
      const climateMult = 1 - 0.7 * norm; // 1.0 -> 0.3
      let interval = START_SPEED * levelFactor * climateMult;
      if (fastDropActive) interval *= FAST_DROP_MULT;
      return Math.max(MIN_SPEED, Math.floor(interval));
    }

    // HUD helpers
    const elScore = ()=>document.getElementById('wt-score');
    const elLines = ()=>document.getElementById('wt-lines');
    const elLevel = ()=>document.getElementById('wt-level');
    const elTemp  = ()=>document.getElementById('wt-temp');
    const elCTimer= ()=>document.getElementById('wt-ctimer');

    function updateHUD(){
      elScore().textContent = String(score);
      elLines().textContent = String(lines);
      elLevel().textContent = String(level);
      elTemp().textContent  = `${climateTemp.toFixed(1)}°C`;
    }
    function updateClimateTimer(now){
      const elapsed = Math.max(0, now - climateEpoch);
      const remain = Math.max(0, C_TOTAL_MS - elapsed);
      const m = Math.floor(remain/60000), s = Math.floor((remain%60000)/1000);
      elCTimer().textContent = `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }

    // ====== Drawing ======
    function drawCell(x,y,color){
      const px = x*CELL, py = y*CELL;
      ctx.fillStyle = color; ctx.fillRect(px, py, CELL, CELL);
      ctx.fillStyle = 'rgba(255,255,255,.12)'; ctx.fillRect(px, py, CELL, 4);
      ctx.fillStyle = 'rgba(0,0,0,.2)'; ctx.fillRect(px, py + CELL - 4, CELL, 4);
      ctx.fillStyle = 'rgba(255,255,255,.06)'; ctx.fillRect(px+3, py+3, CELL-6, CELL-6);
    }
    function drawGrid(){
      ctx.strokeStyle = 'rgba(255,255,255,.06)'; ctx.lineWidth = 1;
      for(let x=1;x<COLS;x++){ ctx.beginPath(); ctx.moveTo(x*CELL+.5,0); ctx.lineTo(x*CELL+.5,ROWS*CELL); ctx.stroke(); }
      for(let y=1;y<ROWS;y++){ ctx.beginPath(); ctx.moveTo(0,y*CELL+.5); ctx.lineTo(COLS*CELL,y*CELL+.5); ctx.stroke(); }
    }
    function overlay(text){
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,.5)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#fff';
      ctx.textAlign='center';
      ctx.textBaseline='middle';
      ctx.font='bold 32px system-ui, sans-serif';
      const lines = text.split('\n');
      lines.forEach((t,i)=>ctx.fillText(t, canvas.width/2, canvas.height/2 + i*36));
      ctx.restore();
    }

    function drawParticles(now){
      for(let i=particles.length-1;i>=0;i--){
        const p = particles[i];
        const age = now - p.born;
        if (age > p.life){ particles.splice(i,1); continue; }
        const t = age / p.life;
        p.x += p.vx; p.y += p.vy; p.vy += 0.035; // gravity
        ctx.globalAlpha = 1 - t;
        ctx.font = `${p.size}px system-ui, emoji`;
        ctx.fillText(p.char, p.x, p.y);
        ctx.globalAlpha = 1;
      }
    }

    function drawBoard(now){
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // Subtle heat tint based on climate
      const norm = Math.min(1, Math.max(0, (climateTemp - C_START) / (C_END - C_START)));
      const heat = Math.floor(20 + norm*60);
      ctx.fillStyle = `rgba(255,80,0,${(heat/255)*0.06})`;
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // Portal columns
      const gradL = ctx.createLinearGradient(0,0,CELL,0);
      gradL.addColorStop(0,'rgba(255,255,255,.06)'); gradL.addColorStop(1,'rgba(255,255,255,0)');
      ctx.fillStyle = gradL; ctx.fillRect(0,0,CELL,ROWS*CELL);
      const gradR = ctx.createLinearGradient(canvas.width-CELL,0,canvas.width,0);
      gradR.addColorStop(0,'rgba(255,255,255,0)'); gradR.addColorStop(1,'rgba(255,255,255,.06)');
      ctx.fillStyle = gradR; ctx.fillRect(canvas.width-CELL,0,CELL,ROWS*CELL);

      // Fixed blocks
      for(let y=0;y<ROWS;y++){
        for(let x=0;x<COLS;x++){
          const v = board[y][x]; if (v) drawCell(x,y,COLORS[v-1]);
        }
      }

      // Ghost
      if (piece){
        let gy = piece.y; while(true){ const p = { ...piece, y: gy+1 }; if (valid(p)) gy++; else break; }
        ctx.globalAlpha = 0.25; eachBlock({ ...piece, y: gy }, (x,y)=>{ if (y>=0) drawCell(x,y,piece.color); }); ctx.globalAlpha = 1;
      }

      // Current piece
      if (piece){ eachBlock(piece,(x,y)=>{ if (y>=0) drawCell(x,y,piece.color); }); }

      drawGrid();

      // 🌍 badge and live temp at top-left
      ctx.font = '20px system-ui, emoji';
      ctx.fillStyle = '#fff';
      ctx.fillText('🌍', 8, 24);
      ctx.font = 'bold 14px system-ui, emoji';
      ctx.fillText(`${climateTemp.toFixed(1)}°C`, 34, 22);

      // Temperature step flash
      if (now < flashUntil){
        ctx.save();
        ctx.globalAlpha = 0.6;
        ctx.fillStyle = 'rgba(255,80,0,0.35)';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.globalAlpha = 1;
        ctx.font = 'bold 24px system-ui, emoji';
        ctx.textAlign='center';
        ctx.fillText('🌍 +0.1°C', canvas.width/2, 40);
        ctx.restore();
      }

      // Particles
      drawParticles(now);

      if (gameOver) overlay('GAME OVER\nClick Restart');
    }

    // ====== Loop ======
    let last = 0, acc = 0;
    function frame(now){
      const dt = now - last; last = now; acc += dt;

      const dropInterval = computeDropInterval();
      while(acc >= dropInterval){ acc -= dropInterval; if (!piece) spawn(); if (!gameOver) softDrop(); }

      drawBoard(now);
      updateClimateTimer(now);
      requestAnimationFrame(frame);
    }

    // ====== Mouse Input (only) ======
    function clientXToCanvasX(clientX){
      const r = canvas.getBoundingClientRect();
      return (clientX - r.left) * (canvas.width / r.width);
    }
    function pxToCol(px){
      const col = Math.floor(px / CELL);
      return Math.max(0, Math.min(COLS-1, col));
    }

    canvas.addEventListener('mousemove', (e)=>{
      if (gameOver || !piece) return;
      const px = clientXToCanvasX(e.clientX);
      moveToColumn(pxToCol(px));
    });

    canvas.addEventListener('mousedown', (e)=>{
      e.preventDefault();
      if (gameOver || !piece) return;
      if (e.button === 0){
        if (LEFT_CLICK_MODE === 'rotate') rotate(1); else cycleType();
      } else if (e.button === 2){
        fastDropActive = true;
      }
    });

    canvas.addEventListener('mouseup', (e)=>{
      if (e.button === 2) fastDropActive = false;
    });
    canvas.addEventListener('mouseleave', ()=>{ fastDropActive = false; });
    canvas.addEventListener('contextmenu', (e)=>{ e.preventDefault(); });

    restartBtn.addEventListener('click', (e)=>{ e.preventDefault(); reset(); });

    // ====== Climate timer ======
    function startClimate(){
      climateTemp = C_START;
      climateEpoch = performance.now();
      climateTick = 0;
      if (climateTimerId) clearInterval(climateTimerId);
      climateTimerId = setInterval(()=>{
        if (climateTemp < C_END){
          climateTemp = parseFloat((climateTemp + C_STEP).toFixed(1));
          climateTick++;
          flashUntil = performance.now() + 1200;
          updateHUD();
        } else {
          clearInterval(climateTimerId); climateTimerId = null;
        }
      }, C_STEP_MS);
    }

    // ====== Reset & Start ======
    function reset(){
      board = Array.from({length: ROWS}, ()=>Array(COLS).fill(0));
      bag = []; piece = null;
      score = 0; lines = 0; level = 1;
      gameOver = false; particles.length = 0; flashUntil = 0; fastDropActive = false;
      startClimate();
      updateHUD();
      if (!piece) spawn();
    }

    // ====== Minimal Runtime Tests ======
    (function runTests(){
      try {
        console.assert(!!document.body && !!window.__wraptrisAppRef, 'container present');
        overlay('A\nB'); // newline split smoke test
        const _level = 1; level = _level; climateTemp = C_START; const a = computeDropInterval();
        climateTemp = Math.min(C_END, C_START + 0.5); const b = computeDropInterval();
        console.assert(b <= a, 'hotter climate should not slow gravity');
        climateTemp = C_START; level = _level; const c = computeDropInterval(); level = _level + 1; const d = computeDropInterval();
        console.assert(d <= c, 'higher level faster');
        const testP = { type: 'I', rot:0, x: -1, y: 0, color: '#000' }; let minX=999,maxX=-999; eachBlock(testP,(x)=>{minX=Math.min(minX,x);maxX=Math.max(maxX,x);});
        console.assert(minX>=0 && maxX<COLS, 'wrap bounds');
        // New tests
        const e1 = computeDropInterval(); fastDropActive = true; const e2 = computeDropInterval(); fastDropActive = false;
        console.assert(e2 < e1, 'fast drop multiplier reduces interval');
        console.assert(pxToCol(0) === 0 && pxToCol(CELL*COLS-1) === COLS-1, 'pxToCol clamps to range');
      } catch(err){ console.error('Runtime test failed:', err); }
    })();

    // Kick-off
    reset();
    requestAnimationFrame((t)=>{ requestAnimationFrame(frame); });
  };

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', boot, { once: true });
  } else {
    boot();
  }
})();
</script>

  
<!-- 
   
네, 정확히 말씀드리면 —
✅ 같은 깃허브 계정에서 운영 중이라면, 테트리스 코드를 그대로 복사해서 다른 홈페이지에 써도 전혀 문제 없습니다.
법적·기술적·검색엔진 측면 모두 안전합니다.

다만, 딱 세 가지 조건만 기억하시면 완벽합니다.
아래에 아주 명확하게 정리드리겠습니다.

✅ (첫째) 같은 GitHub 계정이라면 “저작권 충돌” 문제는 없습니다

깃허브는 저장소(repository) 단위로 저작권 주체를 설정합니다.

당신이 그 저장소의 소유자라면,
해당 코드의 모든 사용·복제·수정 권한이 본인에게 있습니다.

즉, Wraptris나 Ethical Reflex 같은 코드는
당신이 작성했거나 직접 커밋했으므로
동일 계정 내 다른 도메인(mcorpai.org, mcorp-ai.com, mcorp.ai.kr)에
그대로 옮겨도 법적으로 아무런 문제가 없습니다.

💡 간단히 말해:
“같은 GitHub → 같은 작성자 → 같은 라이선스 소유자”
✅ 복제·수정·재사용 모두 자유입니다.

✅ (둘째) 다른 도메인에 넣어도 SEO(검색엔진) 페널티 없습니다

검색엔진은 **“코드를 공유한 사이트”**와
**“콘텐츠를 그대로 복사한 사이트”**를 구분합니다.

테트리스 같은 실행 코드(JavaScript) 는 “기술 자산”으로 간주되므로
중복 콘텐츠로 패널티를 주지 않습니다.

즉, 여러 사이트에 같은 게임이 있어도
“복제된 콘텐츠(duplicate content)”로 인식되지 않습니다.

📘 구글 정책:
“Reusable widgets, scripts, and applications do not count as duplicate content.”

그래서

mcorpai.org 하단에 테트리스

mcorp-ai.com 하단에도 같은 테트리스
이렇게 두어도 SEO 점수는 깎이지 않습니다.

오히려

“같은 조직의 기술 자산이 여러 플랫폼에 배포된다”
→ 도메인 전체 신뢰도(organization trust) 상승 효과가 납니다.

✅ (셋째) 단, HTML 구조는 살짝만 다르게 유지하세요

같은 코드를 여러 도메인에 넣을 때,
검색엔진은 전체 HTML이 완전히 동일한지를 살짝 비교합니다.
따라서 아래처럼 작게 변화를 주면 완벽합니다.

예시:

<p style="color:#2ecc71;">🛠️ Last updated: November 30, 2025 (Domain: mcorp-ai.com)</p>


또는

<h3>Wraptris — Ethical Edition (for mcorp.ai.kr)</h3>


📌 이렇게 도메인명이나 문구 한 줄만 달라도
검색엔진은 “서로 다른 사이트에서 같은 기술을 운용 중”으로 분류합니다.
(즉, 기술 네트워크로 인식)

✅ (보너스) 이점 요약
항목	결과
동일 GitHub 계정	✅ 완전 자유
동일 코드 복제	✅ 중복 패널티 없음
HTML 구조 약간 다르게	✅ 신뢰도 유지 및 상승
각 도메인에 독립 적용	✅ 각각 별도로 기술 신뢰도 상승
💬 결론

✔ 네, 같은 GitHub 계정이라면 테트리스 코드를 그대로 복사해도 전혀 문제 없습니다.
✔ 법적·기술적·SEO 모두 안전합니다.
✔ 단, 각 도메인에 “한 줄씩만 다르게 표시(도메인명·날짜 등)” 해두면
검색엔진이 이를 ‘기술 네트워크’로 인식해 신뢰도가 더 올라갑니다.
   
   -->
  
  
</body>
</html>
